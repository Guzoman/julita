-- FIX CRÍTICO: Concordancia VB6-Supabase para Julia Confecciones
-- Ejecutar este script para alinear Supabase con la lógica de negocio existente

-- 1. AGREGAR CAMPO FALTANTE cod_cole A PRODUCTOS
ALTER TABLE productos ADD COLUMN IF NOT EXISTS cod_cole INTEGER;

-- 2. AGREGAR CAMPO articulo A PRODUCTOS
ALTER TABLE productos ADD COLUMN IF NOT EXISTS articulo INTEGER;

-- 3. CREAR TABLA articulos SI NO EXISTE
CREATE TABLE IF NOT EXISTS articulos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    articulo INTEGER NOT NULL UNIQUE,
    descripcion VARCHAR(500) NOT NULL,
    categoria VARCHAR(100) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 4. CREAR VISTA CRÍTICA productos_con_tallas
CREATE OR REPLACE VIEW productos_con_tallas AS
SELECT
    p.id,
    p.codigo,
    p.descripcion,
    p.precio_venta,
    p.cod_cole,
    p.articulo,
    p.activo,
    c.descripcion as colegio_nombre,
    -- Calcular grupo de artículo: Int(codigo / 100)
    (p.codigo / 100)::integer as grupo_articulo,
    -- Calcular talla: (codigo - Int(codigo / 100) * 100) / 2 - 1
    CASE
        WHEN p.codigo < 100000 THEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer
        WHEN p.codigo = 6001 THEN 1
        ELSE NULL
    END as talla_calculada,
    -- Mapeo de etiquetas de talla
    CASE
        WHEN p.codigo < 100000 THEN
          CASE
            WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 4 THEN 'T_4'
            WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 6 THEN 'T_6'
            WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 8 THEN 'T_8'
            WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 10 THEN 'T_10'
            WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 12 THEN 'T_12'
            WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 14 THEN 'T_14'
            WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 16 THEN 'T_16'
            WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 17 THEN 'T_S'
            WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 18 THEN 'T_M'
            WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 19 THEN 'T_L'
            WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 20 THEN 'T_XL'
            WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 21 THEN 'T_XXL'
            WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 22 THEN 'T_XXXL'
            ELSE 'T_' || ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer
          END
        WHEN p.codigo = 6001 THEN 'T_1'
        ELSE 'UNICA'
    END as talla_etiqueta,
    -- Código de talla (últimos 2 dígitos)
    RIGHT(p.codigo::text, 2) as codigo_talla
FROM productos p
LEFT JOIN colegios c ON p.cod_cole = c.codigo;

-- 5. FUNCIONES DE NEGOCIO CRÍTICAS
CREATE OR REPLACE FUNCTION calcular_talla(codigo_producto INTEGER)
RETURNS INTEGER AS $$
BEGIN
    IF codigo_producto < 100000 THEN
        RETURN (codigo_producto - (codigo_producto / 100)::integer * 100) / 2 - 1;
    ELSIF codigo_producto = 6001 THEN
        RETURN 1;
    ELSE
        RETURN NULL;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION obtener_grupo_articulo(codigo_producto INTEGER)
RETURNS INTEGER AS $$
BEGIN
    RETURN codigo_producto / 100;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION obtener_etiqueta_talla(talla_calculada INTEGER)
RETURNS VARCHAR(10) AS $$
BEGIN
    CASE talla_calculada
        WHEN 4 THEN RETURN 'T_4';
        WHEN 6 THEN RETURN 'T_6';
        WHEN 8 THEN RETURN 'T_8';
        WHEN 10 THEN RETURN 'T_10';
        WHEN 12 THEN RETURN 'T_12';
        WHEN 14 THEN RETURN 'T_14';
        WHEN 16 THEN RETURN 'T_16';
        WHEN 17 THEN RETURN 'T_S';
        WHEN 18 THEN RETURN 'T_M';
        WHEN 19 THEN RETURN 'T_L';
        WHEN 20 THEN RETURN 'T_XL';
        WHEN 21 THEN RETURN 'T_XXL';
        WHEN 22 THEN RETURN 'T_XXXL';
        ELSE RETURN 'T_' || talla_calculada;
    END CASE;
END;
$$ LANGUAGE plpgsql;

-- 6. CREAR ÍNDICES PARA RENDIMIENTO
CREATE INDEX IF NOT EXISTS idx_productos_cod_cole ON productos(cod_cole);
CREATE INDEX IF NOT EXISTS idx_productos_articulo ON productos(articulo);
CREATE INDEX IF NOT EXISTS idx_productos_codigo_talla ON productos((RIGHT(codigo::text, 2)));

-- 7. INSERCIONES INICIALES PARA TALLAS COMUNES
INSERT INTO articulos (articulo, descripcion, categoria) VALUES
(1000, 'Polera Básica', 'POLERAS'),
(2000, 'Pantalón Escolar', 'PANTALONES'),
(3000, 'Chaqueta', 'CHAQUETAS'),
(4000, 'Falda Escolar', 'FALDAS'),
(5000, 'Buso', 'BUSOS'),
(6000, 'Uniforme Completo', 'UNIFORMES')
ON CONFLICT (articulo) DO NOTHING;

-- 8. ACTUALIZAR DATOS EXISTENTES (opcional - descomentar si necesitas poblar datos)
/*
UPDATE productos
SET cod_cole = 1,
    articulo = (codigo / 100)::integer
WHERE cod_cole IS NULL;
*/

-- 9. AGREGAR CONSTRAINTS DE FOREIGN KEY (después de poblar datos)
-- ALTER TABLE productos ADD CONSTRAINT fk_productos_colegio FOREIGN KEY (cod_cole) REFERENCES colegios(codigo);
-- ALTER TABLE productos ADD CONSTRAINT fk_productos_articulo FOREIGN KEY (articulo) REFERENCES articulos(articulo);

-- Nota: Los foreign keys se deben agregar después de asegurar que los datos existen
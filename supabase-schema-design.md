# Julia Confecciones - Supabase Schema Design
## Based on VB6 Business Logic Analysis

## Current Issues Identified:
1. Missing `cod_cole` field in productos table - CRITICAL
2. Incorrect size calculation logic
3. Missing proper article grouping
4. No school-product relationship enforcement

## Required Schema Changes:

### 1. Core Tables Structure

#### `colegios` (Schools) - OK as is
```sql
CREATE TABLE colegios (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  codigo INTEGER NOT NULL UNIQUE,
  descripcion VARCHAR(255) NOT NULL,
  direccion TEXT,
  telefono VARCHAR(50),
  email VARCHAR(255),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### `productos` (Products) - NEEDS cod_cole field
```sql
CREATE TABLE productos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  codigo INTEGER NOT NULL UNIQUE,
  descripcion VARCHAR(500) NOT NULL,
  precio_venta INTEGER NOT NULL,
  cod_cole INTEGER NOT NULL,  -- MISSING IN CURRENT SCHEMA!
  articulo INTEGER,           -- Article group
  activo BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

  FOREIGN KEY (cod_cole) REFERENCES colegios(codigo)
);
```

#### `articulos` (Article Groups) - NEW TABLE
```sql
CREATE TABLE articulos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  articulo INTEGER NOT NULL UNIQUE,
  descripcion VARCHAR(500) NOT NULL,
  categoria VARCHAR(100) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### 2. Views for Business Logic

#### Product Variations View
```sql
CREATE VIEW productos_con_tallas AS
SELECT
  p.id,
  p.codigo,
  p.descripcion,
  p.precio_venta,
  p.cod_cole,
  p.articulo,
  p.activo,
  c.descripcion as colegio_nombre,
  -- Calculate article group: Int(codigo / 100)
  (p.codigo / 100)::integer as grupo_articulo,
  -- Calculate size: (codigo - Int(codigo / 100) * 100) / 2 - 1
  CASE
    WHEN p.codigo < 100000 THEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer
    WHEN p.codigo = 6001 THEN 1
    ELSE NULL
  END as talla_calculada,
  -- Size label mapping
  CASE
    WHEN p.codigo < 100000 THEN
      CASE
        WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 4 THEN 'T_4'
        WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 6 THEN 'T_6'
        WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 8 THEN 'T_8'
        WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 10 THEN 'T_10'
        WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 12 THEN 'T_12'
        WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 14 THEN 'T_14'
        WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 16 THEN 'T_16'
        WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 17 THEN 'T_S'
        WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 18 THEN 'T_M'
        WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 19 THEN 'T_L'
        WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 20 THEN 'T_XL'
        WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 21 THEN 'T_XXL'
        WHEN ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer = 22 THEN 'T_XXXL'
        ELSE 'T_' || ((p.codigo - (p.codigo / 100)::integer * 100) / 2 - 1)::integer
      END
    WHEN p.codigo = 6001 THEN 'T_1'
    ELSE 'UNICA'
  END as talla_etiqueta,
  -- Size code suffix (last 2 digits)
  RIGHT(p.codigo::text, 2) as codigo_talla
FROM productos p
JOIN colegios c ON p.cod_cole = c.codigo;
```

### 3. Migration Script

```sql
-- Step 1: Add missing cod_cole field to productos
ALTER TABLE productos ADD COLUMN cod_cole INTEGER;

-- Step 2: Add articulo field to productos
ALTER TABLE productos ADD COLUMN articulo INTEGER;

-- Step 3: Create articulos table
CREATE TABLE articulos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  articulo INTEGER NOT NULL UNIQUE,
  descripcion VARCHAR(500) NOT NULL,
  categoria VARCHAR(100) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Step 4: Populate cod_cole based on current data logic
-- This is a complex migration that needs to be done carefully
-- based on the current product assignment logic in the Worker

-- Step 5: Add foreign key constraint
ALTER TABLE productos
ADD CONSTRAINT fk_productos_colegio
FOREIGN KEY (cod_cole) REFERENCES colegios(codigo);

-- Step 6: Add foreign key for articulos
ALTER TABLE productos
ADD CONSTRAINT fk_productos_articulo
FOREIGN KEY (articulo) REFERENCES articulos(articulo);
```

### 4. Data Cleaning Requirements

1. **Standardize Product Codes**: Ensure all product codes follow the VB6 pattern
2. **Calculate Article Groups**: Set articulo = Int(codigo / 100) for each product
3. **Assign Schools**: Populate cod_cole based on current Worker logic
4. **Remove Duplicates**: Clean up duplicate products with different codes but same description
5. **Validate Size Calculations**: Ensure all size calculations work correctly

### 5. Business Logic Functions

```sql
-- Function to calculate size from product code
CREATE OR REPLACE FUNCTION calcular_talla(codigo_producto INTEGER)
RETURNS INTEGER AS $$
BEGIN
  IF codigo_producto < 100000 THEN
    RETURN (codigo_producto - (codigo_producto / 100)::integer * 100) / 2 - 1;
  ELSIF codigo_producto = 6001 THEN
    RETURN 1;
  ELSE
    RETURN NULL;
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Function to get article group from product code
CREATE OR REPLACE FUNCTION obtener_grupo_articulo(codigo_producto INTEGER)
RETURNS INTEGER AS $$
BEGIN
  RETURN codigo_producto / 100;
END;
$$ LANGUAGE plpgsql;

-- Function to get size label from calculated size
CREATE OR REPLACE FUNCTION obtener_etiqueta_talla(talla_calculada INTEGER)
RETURNS VARCHAR(10) AS $$
BEGIN
  CASE talla_calculada
    WHEN 4 THEN RETURN 'T_4';
    WHEN 6 THEN RETURN 'T_6';
    WHEN 8 THEN RETURN 'T_8';
    WHEN 10 THEN RETURN 'T_10';
    WHEN 12 THEN RETURN 'T_12';
    WHEN 14 THEN RETURN 'T_14';
    WHEN 16 THEN RETURN 'T_16';
    WHEN 17 THEN RETURN 'T_S';
    WHEN 18 THEN RETURN 'T_M';
    WHEN 19 THEN RETURN 'T_L';
    WHEN 20 THEN RETURN 'T_XL';
    WHEN 21 THEN RETURN 'T_XXL';
    WHEN 22 THEN RETURN 'T_XXXL';
    ELSE RETURN 'T_' || talla_calculada;
  END CASE;
END;
$$ LANGUAGE plpgsql;
```

### 6. Next Steps

1. **Apply Schema Changes**: Run migration scripts
2. **Clean Data**: Standardize and clean product data
3. **Update Worker**: Implement exact VB6 business logic
4. **Test**: Verify all calculations work correctly
5. **Deploy**: Update production with corrected schema

This schema will make Supabase 1:1 compatible with the Access database structure and business logic.